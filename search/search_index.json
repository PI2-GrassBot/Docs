{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"\ud83c\udf31 GrassBot","text":""},{"location":"#o-que-e-o-grassbot","title":"\ud83d\ude80 O que \u00e9 o GrassBot?","text":"<p>O GrassBot \u00e9 um cortador de grama aut\u00f4nomo inteligente projetado para manter gramados sempre bem cuidados sem interven\u00e7\u00e3o humana. Ele utiliza algoritmos para navega\u00e7\u00e3o, detec\u00e7\u00e3o de obst\u00e1culos e otimiza\u00e7\u00e3o de rota, proporcionando um corte eficiente e preciso.</p> <p></p> <p>Slides Apresenta\u00e7\u00e3o 1 Slides Apresenta\u00e7\u00e3o 2</p>"},{"location":"#principais-funcionalidades","title":"\ud83d\udd25 Principais Funcionalidades","text":"<p>\u2705 Corte Automatizado - Define rotas otimizadas para cobrir toda a \u00e1rea de forma eficiente. \u2705 Detec\u00e7\u00e3o de Obst\u00e1culos - Sensores simulados identificam obst\u00e1culos e recalculam a trajet\u00f3ria. \u2705 Simula\u00e7\u00e3o - Emulador permite testar o software antes da implementa\u00e7\u00e3o f\u00edsica. \u2705 Interface Inteligente - Controle intuitivo para configurar \u00e1rea de corte e visualizar status.  </p>"},{"location":"#arquitetura-do-sistema","title":"\ud83c\udfd7 Arquitetura do Sistema","text":""},{"location":"#especificacoes-tecnicas","title":"\ud83d\udcca Especifica\u00e7\u00f5es T\u00e9cnicas","text":"Caracter\u00edstica Descri\u00e7\u00e3o \ud83d\udda5 Simula\u00e7\u00e3o Implementa\u00e7\u00e3o de ambiente com Pygame \ud83d\udce1 Sensores Mock de Sensores Ultrass\u00f4nicos \u2699 Navega\u00e7\u00e3o Algoritmo de pathfinding otimizado"},{"location":"#casos-de-uso","title":"\ud83c\udfaf Casos de Uso","text":"<p>\u2714 Resid\u00eancias e Jardins - Mant\u00e9m gramados bem cuidados sem esfor\u00e7o. \u2714 Parques e Campos Esportivos - Ideal para \u00e1reas amplas com necessidade de corte uniforme. \u2714 Aplica\u00e7\u00f5es Comerciais - Reduz custos operacionais em manuten\u00e7\u00e3o de gramados.  </p>"},{"location":"#como-testar-o-grassbot","title":"\ud83d\udccc Como Testar o GrassBot?","text":"<p>O software conta com um emulador integrado, permitindo testar os algoritmos antes da implementa\u00e7\u00e3o real. Para executar a simula\u00e7\u00e3o basta seguir as instru\u00e7\u00f5es de run.</p>"},{"location":"#equipe","title":"\ud83e\udd1d Equipe","text":""},{"location":"#caio-vitor-carneiro-de-oliveira","title":"Caio Vitor Carneiro de Oliveira","text":"<ul> <li>GitHub</li> <li>Matricula: 200057227</li> </ul>"},{"location":"#eduardo-maia-rezende","title":"Eduardo Maia Rezende","text":"<ul> <li>GitHub</li> <li>Matricula: 180119231</li> </ul>"},{"location":"#pedro-vitor-augusto-de-jesus","title":"Pedro Vitor Augusto de Jesus","text":"<ul> <li>GitHub</li> <li>Matricula: 200073249</li> </ul>"},{"location":"abordagemv1/","title":"Abordagem V1","text":""},{"location":"abordagemv1/#visao-geral","title":"Vis\u00e3o Geral","text":"<p>Esta documenta\u00e7\u00e3o descreve a abordagem V1 do projeto GrassBot, um simulador de cortador de grama aut\u00f4nomo. O simulador foi desenvolvido em Python e utiliza a biblioteca Pygame para criar uma interface gr\u00e1fica interativa. O GrassBot \u00e9 capaz de cortar grama de forma aut\u00f4noma, evitando obst\u00e1culos.</p>"},{"location":"abordagemv1/#_1","title":"Abordagem V1","text":""},{"location":"abordagemv1/#arquitetura","title":"Arquitetura","text":""},{"location":"abordagemv1/#api-api","title":"API (<code>api</code>)","text":"<p>A api \u00e9 respons\u00e1vel por fornecer uma servidor web para controle do cortador de grama. Tendo os seguintes endpoints que disp\u00f5e atualiza\u00e7\u00e3o em tempo real do estado do cortador. Tais como: - Ligar/Desligar - Aumentar/Diminuir Velocidade - Gerar Mapa Aleat\u00f3rio</p> <p>A api recebe as requisi\u00e7\u00f5es e atualiza o arquivo de configura\u00e7\u00e3o JSON, que \u00e9 lido pelo simulador para atualizar o estado do cortador.</p>"},{"location":"abordagemv1/#nucleo-core","title":"N\u00facleo (<code>Core</code>)","text":"<p>O Core cont\u00e9m os componentes centrais do projeto, respons\u00e1veis por implementar a l\u00f3gica de busca em grafos e manipula\u00e7\u00e3o de n\u00f3s. Essas funcionalidades s\u00e3o essenciais para a navega\u00e7\u00e3o e tomada de decis\u00e3o no ambiente da simula\u00e7\u00e3o.</p> <p>O Core realiza leituras sazonais do json de configura\u00e7\u00e3o, atualizando o estado do cortador.</p>"},{"location":"abordagemv1/#graph_searchpy","title":"graph_search.py","text":"<p>L\u00f3gica de busca em profundidade (DFS - Depth-First Search) no ambiente da simula\u00e7\u00e3o. A DFS \u00e9 usada para explorar os caminhos poss\u00edveis no labirinto ou ambiente de forma sistem\u00e1tica.</p>"},{"location":"abordagemv1/#principais-funcoes","title":"Principais Fun\u00e7\u00f5es","text":""},{"location":"abordagemv1/#dfsmaze-start-gui-coords-coordinates","title":"<code>dfs(maze, start, gui, coords: Coordinates)</code>","text":"<p>Executa a busca em profundidade no ambiente definido pela matriz <code>maze</code>.</p> <p>Par\u00e2metros: - <code>maze</code>: Uma matriz 2D representando o ambiente, onde valores determinam se uma c\u00e9lula \u00e9 acess\u00edvel (0) ou n\u00e3o. - <code>start</code>: A posi\u00e7\u00e3o inicial (tupla <code>(x, y)</code>) para come\u00e7ar a busca. - <code>gui</code>: Interface gr\u00e1fica (GUI) usada para exibir o progresso da busca. - <code>coords: Coordinates</code>: Objeto que armazena o estado atual da busca, como o n\u00f3 corrente e listas abertas e fechadas.</p> <p>Descri\u00e7\u00e3o do Fluxo: 1. Cria um n\u00f3 inicial a partir da posi\u00e7\u00e3o de in\u00edcio. 2. Utiliza duas listas:    - <code>open_list</code>: Cont\u00e9m os n\u00f3s que ser\u00e3o explorados.    - <code>closed_list</code>: Cont\u00e9m os n\u00f3s j\u00e1 visitados. 3. Itera enquanto houver n\u00f3s na <code>open_list</code>:    - Atualiza o n\u00f3 atual.    - Verifica vizinhos usando <code>get_sensors</code>.    - Filtra os vizinhos intransit\u00e1veis ou j\u00e1 visitados.    - Adiciona novos vizinhos \u00e0 <code>open_list</code>. 4. Renderiza o progresso na interface gr\u00e1fica (<code>gui.sprite(True)</code>).</p> <p>Conex\u00f5es Importantes: - Usa a fun\u00e7\u00e3o <code>get_sensors</code> do m\u00f3dulo <code>sensors.get_sensors</code> para obter vizinhos do n\u00f3 atual. - Utiliza a classe <code>Node</code> para manipular n\u00f3s no grafo.</p>"},{"location":"abordagemv1/#nodepy","title":"node.py","text":"<p>Define a classe <code>Node</code>, que \u00e9 usada para representar n\u00f3s no grafo durante a execu\u00e7\u00e3o do algoritmo de busca.</p>"},{"location":"abordagemv1/#classe-node","title":"Classe <code>Node</code>","text":"<p>Representa um n\u00f3 no grafo ou na matriz.</p> <p>Atributos:</p> <ul> <li><code>parent</code>: O n\u00f3 pai (do tipo <code>Node</code>) usado para rastrear o caminho percorrido.</li> <li><code>position</code>: A posi\u00e7\u00e3o do n\u00f3, representada como uma tupla <code>(x, y)</code>.</li> </ul> <p>M\u00e9todos:</p> <ul> <li><code>__init__(self, parent: Node, position: Tuple[int, int])</code>: Inicializa o n\u00f3 com um pai e uma posi\u00e7\u00e3o.</li> <li><code>__eq__(self, other: Node)</code>: Compara dois n\u00f3s pela posi\u00e7\u00e3o, retornando <code>True</code> se forem iguais.</li> </ul> <p>Importante para:</p> <ul> <li>Rastrear o caminho percorrido durante a busca.</li> <li>Comparar n\u00f3s e evitar redund\u00e2ncias.</li> </ul>"},{"location":"abordagemv1/#simulation-simulation","title":"Simulation (<code>Simulation</code>)","text":"<p>O m\u00f3dulo de simula\u00e7\u00e3o cont\u00e9m os arquivos respons\u00e1veis por criar a interface gr\u00e1fica do simulador. Ele utiliza a biblioteca Pygame para renderizar o ambiente e exibir o progresso da busca em tempo real.</p>"},{"location":"abordagemv1/#drawerpy","title":"drawer.py","text":""},{"location":"abordagemv1/#classe-coordinates","title":"Classe <code>Coordinates</code>","text":"<p>A classe <code>Coordinates</code> gerencia os dados relacionados ao labirinto, como posi\u00e7\u00e3o inicial, obst\u00e1culos e listas utilizadas em algoritmos de busca.</p>"},{"location":"abordagemv1/#atributos","title":"Atributos","text":"<ul> <li><code>start</code>: N\u00f3 inicial (<code>Node</code>).</li> <li><code>walls</code>: Lista de coordenadas que representam paredes no labirinto.</li> <li><code>maze</code>: Representa\u00e7\u00e3o matricial do labirinto.</li> <li><code>open_list</code>: Lista de n\u00f3s a serem processados.</li> <li><code>closed_list</code>: Lista de n\u00f3s j\u00e1 processados.</li> <li><code>current_node</code>: N\u00f3 atualmente processado.</li> <li><code>start_point</code>: Coordenadas do ponto inicial no formato <code>(x, y)</code>.</li> </ul>"},{"location":"abordagemv1/#metodos","title":"M\u00e9todos","text":"<ol> <li><code>__init__(self)</code>: Inicializa os atributos chamando <code>clear_all_field()</code>.</li> <li><code>clear_all_field(self)</code>: Reseta todos os atributos para seus valores padr\u00e3o.</li> <li><code>clear_cut(self)</code>: Limpa o labirinto, a lista aberta e a lista fechada, mantendo as paredes.</li> <li><code>largest_distance(self)</code>: Calcula o maior \u00edndice entre as paredes e o ponto inicial.</li> <li><code>create_maze(self, gui)</code>: Cria a matriz do labirinto com base no tamanho da grid e nas paredes definidas.</li> <li><code>generate_random_obstacles(self, gui)</code>: Gera obst\u00e1culos aleat\u00f3rios na grid com base em uma probabilidade.</li> </ol>"},{"location":"abordagemv1/#guipy","title":"gui.py","text":""},{"location":"abordagemv1/#classe-gui","title":"Classe <code>Gui</code>","text":"<p>A classe <code>Gui</code> gerencia a interface gr\u00e1fica do sistema utilizando o Pygame. Ela tamb\u00e9m controla os eventos e a l\u00f3gica do jogo.</p>"},{"location":"abordagemv1/#atributos_1","title":"Atributos","text":"<ul> <li><code>grid_size</code>: Tamanho da grid.</li> <li><code>box_width</code>: Largura de cada c\u00e9lula no grid.</li> <li><code>coords</code>: Inst\u00e2ncia da classe <code>Coordinates</code>.</li> <li><code>placing_blocks</code>: Indica se blocos (paredes) est\u00e3o sendo colocados.</li> <li><code>removing_blocks</code>: Indica se blocos est\u00e3o sendo removidos.</li> <li><code>cut_speed</code>: Velocidade de execu\u00e7\u00e3o do algoritmo.</li> <li><code>cut_height</code>: Altura de corte utilizada pelo sistema.</li> <li><code>pause</code>: Indica se o jogo est\u00e1 pausado.</li> <li><code>status</code>: String representando o estado atual do jogo.</li> <li><code>running</code>: Indica se o algoritmo est\u00e1 em execu\u00e7\u00e3o.</li> </ul>"},{"location":"abordagemv1/#metodos_1","title":"M\u00e9todos","text":"<ol> <li><code>__init__(self, coords)</code>: Inicializa a interface gr\u00e1fica e os atributos.</li> <li><code>sprite(self, is_running=False)</code>: Loop principal que controla o estado do jogo.</li> <li><code>read_event_by_api(self)</code>: L\u00ea eventos de um arquivo JSON para integra\u00e7\u00e3o com uma API externa.</li> <li><code>power(self, running)</code>: Controla o estado de execu\u00e7\u00e3o com base em comandos da API.</li> <li><code>event_handle(self, running)</code>: Gerencia eventos do teclado e mouse.</li> <li><code>redraw(self)</code>: Atualiza a interface gr\u00e1fica.</li> <li><code>draw_grid(self)</code>: Desenha a grade do labirinto.</li> <li><code>draw_points(self)</code>: Desenha os pontos relevantes, como paredes, n\u00f3s visitados e ponto inicial.</li> <li><code>draw_box(self, box, colour)</code>: Desenha uma c\u00e9lula espec\u00edfica do grid.</li> <li><code>get_box_coords(self) -&gt; Tuple[int, int]</code>: Retorna as coordenadas da c\u00e9lula sob o mouse.</li> <li><code>place_start(self)</code>: Define o ponto inicial com base na posi\u00e7\u00e3o do mouse.</li> <li><code>place_wall(self)</code>: Adiciona uma parede na posi\u00e7\u00e3o atual do mouse.</li> <li><code>remove(self)</code>: Remove uma parede ou ponto inicial da posi\u00e7\u00e3o atual do mouse.</li> <li><code>run_algorithm(self)</code>: Executa o algoritmo DFS com base no estado atual do labirinto.</li> <li><code>panel_status(self)</code>: Atualiza o painel lateral com informa\u00e7\u00f5es do jogo.</li> </ol>"},{"location":"abordagemv1/#sensores-sensors","title":"Sensores (<code>Sensors</code>)","text":"<p>O foco de <code>Sensors</code> \u00e9 identificar os vizinhos diretos de um n\u00f3 em uma grade ou matriz, considerando os movimentos b\u00e1sicos em quatro dire\u00e7\u00f5es: cima, baixo, esquerda e direita. Esses vizinhos representam os n\u00f3s adjacentes que podem ser acessados a partir da posi\u00e7\u00e3o atual.</p>"},{"location":"abordagemv1/#get_sensorspy","title":"get_sensors.py","text":"<p>A fun\u00e7\u00e3o \u00e9 utilizada no algoritmo de busca em grafos utilizado para mapear o ambiente e calcular a rota, neste caso o DFS (Depth-First Search) , para explorar caminhos ou estados vizinhos em problemas de navega\u00e7\u00e3o, labirintos ou grade de obst\u00e1culos.</p>"},{"location":"abordagemv1/#interface-ui","title":"Interface (<code>Ui</code>)","text":"<p>A interface do usu\u00e1rio \u00e9 respons\u00e1vel por fornecer uma p\u00e1gina web com os controles do cortador de grama. Ela permite ligar/desligar o cortador, ajustar a velocidade e gerar um mapa aleat\u00f3rio.</p>"},{"location":"abordagemv2/","title":"Abordagem V2","text":""},{"location":"abordagemv2/#visao-geral","title":"Vis\u00e3o Geral","text":"<p>Esta documenta\u00e7\u00e3o descreve a abordagem V2 do projeto GrassBot, um simulador de cortador de grama aut\u00f4nomo. O simulador foi desenvolvido em Python e utiliza a biblioteca Pygame para criar uma interface gr\u00e1fica interativa. O GrassBot \u00e9 capaz de cortar grama de forma aut\u00f4noma, evitando obst\u00e1culos e otimizando rotas.</p>"},{"location":"abordagemv2/#_1","title":"Abordagem V2","text":""},{"location":"abordagemv2/#arquitetura","title":"Arquitetura","text":""},{"location":"abordagemv2/#nucleo-core","title":"N\u00facleo (<code>Core</code>)","text":"<p>O n\u00facleo do projeto gerencia os estados principais do cortador, como posi\u00e7\u00e3o, velocidade e estado de energia.</p>"},{"location":"abordagemv2/#exemplo-de-codigo","title":"Exemplo de C\u00f3digo:","text":"<pre><code>class Core:\n    def __init__(self, x: int, y: int):\n        self.x = x\n        self.y = y\n        self.atualiza_comando()\n        self.posicao_atual = (self.x, self.y)\n\n    def ligar(self):\n        self.power = True\n\n    def desligar(self):\n        self.power = False\n\n    def atualiza_comando(self):\n        with open('src/api/data/data.json') as f:\n            data = json.load(f)\n\n        self.power = data['ligado']\n        self.velocidade = data['velocidade']\n        self.altura = data['altura_corte']\n        return self.power, self.velocidade, self.altura\n</code></pre> <p>O m\u00e9todo <code>atualiza_comando</code> sincroniza o estado do cortador com o arquivo de configura\u00e7\u00e3o JSON, que recebe os valores de acordo com a interface de usu\u00e1rio web.</p>"},{"location":"abordagemv2/#sensores","title":"Sensores","text":"<p>Os sensores simulados detectam obst\u00e1culos, grama e zonas de concreto, permitindo ao cortador recalcular rotas de forma aut\u00f4noma.</p>"},{"location":"abordagemv2/#exemplo-de-codigo_1","title":"Exemplo de C\u00f3digo:","text":"<pre><code>class MockSensors:\n    def get_data(self, x, y):\n        return [\n            {\"posicao\": (x + 30, y), \"direcao\": \"RIGHT\", \"tipo\": \"Grama\"},\n            {\"posicao\": (x, y + 30), \"direcao\": \"DOWN\", \"tipo\": \"Concreto\"}\n        ]\n</code></pre> <p>Os sensores retornam dados sobre o ambiente ao redor, que s\u00e3o usados no planejamento de movimento.</p>"},{"location":"abordagemv2/#simulacao","title":"Simula\u00e7\u00e3o","text":"<p>Usa o Pygame para criar uma interface gr\u00e1fica interativa que representa o campo de grama, obst\u00e1culos e o cortador.</p>"},{"location":"abordagemv2/#exemplo-de-codigo_2","title":"Exemplo de C\u00f3digo:","text":"<pre><code>class Cortador:\n    def mover(self):\n        if self.direcao == \"UP\":\n            self.core.y -= TAMANHO_CORTADOR\n        elif self.direcao == \"DOWN\":\n            self.core.y += TAMANHO_CORTADOR\n        elif self.direcao == \"LEFT\":\n            self.core.x -= TAMANHO_CORTADOR\n        elif self.direcao == \"RIGHT\":\n            self.core.x += TAMANHO_CORTADOR\n\n        self.core.x = max(0, min(self.core.x, LARGURA - TAMANHO_CORTADOR))\n        self.core.y = max(0, min(self.core.y, ALTURA - TAMANHO_CORTADOR))\n</code></pre> <p>O cortador se move no ambiente, ajustando sua posi\u00e7\u00e3o conforme os limites do mapa e evitando \u00e1reas intransit\u00e1veis.</p>"},{"location":"abordagemv2/#interface-de-usuario","title":"Interface de Usu\u00e1rio","text":"<p>Exibe informa\u00e7\u00f5es em tempo real, como a posi\u00e7\u00e3o do cortador e sua velocidade.</p>"},{"location":"abordagemv2/#exemplo-de-codigo_3","title":"Exemplo de C\u00f3digo:","text":"<pre><code>class Painel:\n    def desenhar(self):\n        texto_posicao = fonte.render(f\"Posi\u00e7\u00e3o: ({self.cortador.core.x // TAMANHO_CORTADOR}, {self.cortador.core.y // TAMANHO_CORTADOR})\", True, COR_TEXTO)\n        tela.blit(texto_posicao, (LARGURA + 10, 310))\n</code></pre> <p>O painel fornece feedback visual detalhado durante a execu\u00e7\u00e3o do simulador.</p>"},{"location":"abordagemv2/#algoritmo-de-autonomia","title":"Algoritmo de Autonomia","text":"<p>O cortador utiliza um algoritmo de navega\u00e7\u00e3o para explorar a \u00e1rea de forma eficiente.</p>"},{"location":"abordagemv2/#passos-principais","title":"Passos Principais:","text":"<ol> <li>Coleta de Dados    Os sensores identificam o tipo de terreno e a presen\u00e7a de obst\u00e1culos.</li> </ol> <p><code>python    dados_sensores = self.sensores.get_data(self.core.x, self.core.y)</code></p> <ol> <li>Recalculo de Rotas    Quando encontra um obst\u00e1culo, o cortador recalcula a rota com base nos dados dos sensores.</li> </ol> <p><code>python    def recaucular_rota(self):        for dado in dados_sensores:            if dado[\"tipo\"] == \"Grama\" and not dado[\"posicao\"] in self.visitados:                return dado[\"direcao\"]</code></p> <ol> <li>Busca em Largura (BFS)    Caso todas as dire\u00e7\u00f5es imediatas estejam bloqueadas, o algoritmo utiliza BFS para encontrar a c\u00e9lula de grama mais pr\u00f3xima.</li> </ol> <p><code>python    def buscar_grama_mais_proxima(self):        fila = [(self.core.x, self.core.y)]        while fila:            x, y = fila.pop(0)            if not grama_cortada[y // TAMANHO_CORTADOR][x // TAMANHO_CORTADOR]:                return (x, y)</code></p>"},{"location":"abordagemv2/#fluxo-de-execucao","title":"Fluxo de Execu\u00e7\u00e3o","text":"<ol> <li>O simulador \u00e9 iniciado pelo script principal (<code>main.py</code>).</li> <li>O cortador come\u00e7a na posi\u00e7\u00e3o inicial, verificando a grama ao redor e movendo-se conforme as condi\u00e7\u00f5es do ambiente.</li> <li>O painel exibe informa\u00e7\u00f5es em tempo real.</li> <li>O simulador encerra automaticamente quando toda a grama \u00e9 cortada.</li> </ol>"},{"location":"abordagemv2/#possiveis-extensoes","title":"Poss\u00edveis Extens\u00f5es","text":"<ul> <li>Mapas Personaliz\u00e1veis: Permitir que os usu\u00e1rios configurem mapas com obst\u00e1culos e zonas especiais.</li> <li>Integra\u00e7\u00e3o com IA: Incorporar aprendizado de m\u00e1quina para otimizar o padr\u00e3o de corte.</li> <li>Melhorias nos Sensores: Simular condi\u00e7\u00f5es ambientais, como chuva ou ilumina\u00e7\u00e3o vari\u00e1vel.</li> </ul> <p>Este projeto fornece uma base para simula\u00e7\u00f5es de dispositivos aut\u00f4nomos e pode ser expandido para incluir funcionalidades mais avan\u00e7adas.</p>"},{"location":"arquitetura/","title":"Aruitetura","text":""},{"location":"arquitetura/#introducao","title":"Introdu\u00e7\u00e3o","text":"<p>A arquitetura apresentada na imagem abaixo consiste em um sistema de corte de grama automatizado, que funciona de maneira aut\u00f4noma, detectando obst\u00e1culos, otimizando rotas e garantindo um corte preciso sem interven\u00e7\u00e3o humana direta. O sistema \u00e9 composto por tres servi\u00e7os principais: a interface de usu\u00e1rio, a API de comunica\u00e7\u00e3o e o simulador de ambiente.</p> <p></p>"},{"location":"arquitetura/#componentes","title":"Componentes","text":""},{"location":"arquitetura/#interface-de-usuario","title":"Interface de Usu\u00e1rio","text":"<p>A interface de usu\u00e1rio \u00e9 respons\u00e1vel por permitir a intera\u00e7\u00e3o com o sistema de corte de grama automatizado. Nela, o usu\u00e1rio pode configurar a altura de corte, visualizar o status do equipamento e monitorar o status da opera\u00e7\u00e3o de corte. A interface \u00e9 implementada em uma aplica\u00e7\u00e3o web com a utiliza\u00e7\u00e3o de Flask, um framework de desenvolvimento web em Python.</p>"},{"location":"arquitetura/#api-de-comunicacao","title":"API de Comunica\u00e7\u00e3o","text":"<p>A API de comunica\u00e7\u00e3o \u00e9 respons\u00e1vel por receber as requisi\u00e7\u00f5es da interface de usu\u00e1rio e repass\u00e1-las para o simulador de ambiente. Ela \u00e9 implementada em Python com o uso do FastAPI, um framework web de alto desempenho.</p> <p>Componentes da API:</p> <ul> <li>Routers: Os routers organizam os diferentes endpoints em m\u00f3dulos, facilitando a manuten\u00e7\u00e3o e escalabilidade do c\u00f3digo.</li> <li>Models: Definem a estrutura dos dados trocados entre a interface e a API. Esses modelos s\u00e3o usados para valida\u00e7\u00e3o e serializa\u00e7\u00e3o/deserializa\u00e7\u00e3o de dados.</li> <li>JSON: Os dados processados pela API geralmente s\u00e3o armazenados ou trocados em formato JSON, um padr\u00e3o leve e amplamente suportado.</li> </ul> <p>Funcionalidades Principais da API:</p> <ul> <li>Receber solicita\u00e7\u00f5es da Interface de Usu\u00e1rio.</li> <li>Processar e validar os dados de entrada usando os Models.</li> <li>Disponibilizar as solicita\u00e7\u00e3o para o Core do Simulador de Ambiente.</li> </ul>"},{"location":"arquitetura/#simulador-de-ambiente","title":"Simulador de Ambiente","text":"<p>O simulador de Ambiente \u00e9 composto por tr\u00eas m\u00f3dulos principais: O Core, o Mock de Sensores, e o Simulador de Movimento. O Core \u00e9 respons\u00e1vel por gerenciar a l\u00f3gica de simula\u00e7\u00e3o, como a detec\u00e7\u00e3o de obst\u00e1culos e o c\u00e1lculo de rotas, funcionando como um microcontrolador virtual. O Mock de Sensores simula a leitura de sensores de proximidade e obst\u00e1culos, fornecendo dados para o Core. O Simulador de Movimento, implementado com Pygame, \u00e9 respons\u00e1vel por exibir a simula\u00e7\u00e3o em tempo real, permitindo visualizar o movimento do cortador de grama no ambiente virtual.</p>"},{"location":"arquitetura/#diagrama-de-classes","title":"Diagrama de Classes","text":"<p>O diagrama de classes apresenta a estrutura do GrassBot, mostrando as classes e suas rela\u00e7\u00f5es.</p>"},{"location":"arquitetura/#diagrama-de-classes-v1","title":"Diagrama de Classes V1","text":""},{"location":"benchmark/","title":"Benchmark","text":"<p>Com o objetivo de elicitar os requisitos do projeto GrassBot, realizamos um benchmarking com produtos similares no mercado. A seguir, apresentamos uma an\u00e1lise de alguns cortadores de grama aut\u00f4nomos existentes no mercado, destacando suas principais caracter\u00edsticas.</p> <p>Os cortadores de grama aut\u00f4nomos, tamb\u00e9m conhecidos como rob\u00f4s cortadores de grama, s\u00e3o dispositivos projetados para operar de forma independente, mantendo o gramado aparado sem a necessidade de interven\u00e7\u00e3o humana constante. Eles utilizam sensores, sistemas de navega\u00e7\u00e3o e, em alguns casos, intelig\u00eancia artificial para mapear e cortar a \u00e1rea designada.</p> <p>Principais Caracter\u00edsticas dos Cortadores de Grama Aut\u00f4nomos:</p> <ul> <li> <p>Navega\u00e7\u00e3o Inteligente: Muitos modelos utilizam sensores para detectar obst\u00e1culos e evitar colis\u00f5es, garantindo um corte eficiente e seguro.</p> </li> <li> <p>Programa\u00e7\u00e3o de Hor\u00e1rios: Permitem agendar hor\u00e1rios espec\u00edficos para o corte, oferecendo conveni\u00eancia ao usu\u00e1rio.</p> </li> <li> <p>Recarga Autom\u00e1tica: Alguns dispositivos retornam automaticamente \u00e0 base de carregamento quando a bateria est\u00e1 baixa.</p> </li> <li> <p>Ajuste de Altura de Corte: Possibilitam a configura\u00e7\u00e3o da altura desejada para o corte da grama.</p> </li> </ul> <p>Vantagens:</p> <ul> <li> <p>Autonomia: Operam sem supervis\u00e3o constante, economizando tempo e esfor\u00e7o.</p> </li> <li> <p>Consist\u00eancia: Mant\u00eam o gramado com apar\u00eancia uniforme atrav\u00e9s de cortes regulares.</p> </li> <li> <p>Efici\u00eancia Energ\u00e9tica: Muitos modelos s\u00e3o el\u00e9tricos, contribuindo para a redu\u00e7\u00e3o de emiss\u00f5es de carbono.</p> </li> </ul> <p>Desafios:</p> <ul> <li> <p>Pre\u00e7o: O investimento inicial pode ser elevado em compara\u00e7\u00e3o com cortadores tradicionais.</p> </li> <li> <p>Limita\u00e7\u00f5es de Terreno: Podem enfrentar dificuldades em terrenos muito irregulares ou com declives acentuados.</p> </li> </ul> <p>Exemplos de Modelos Populares:</p> <ol> <li> <p>Greenworks Optimow 15: Um rob\u00f4 cortador de grama adequado para \u00e1reas de at\u00e9 1500 m\u00b2, conhecido por sua efici\u00eancia e facilidade de uso. </p> </li> <li> <p>Gardena PowerMax 32/1200 G2: Embora n\u00e3o seja totalmente aut\u00f4nomo, este modelo el\u00e9trico oferece recursos avan\u00e7ados e \u00e9 ideal para jardins de pequeno a m\u00e9dio porte. </p> </li> </ol>"},{"location":"benchmark/#projetos-de-codigo-aberto","title":"Projetos de C\u00f3digo Aberto","text":"<p>Al\u00e9m dos modelos comerciais, existem projetos de c\u00f3digo aberto que permitem a constru\u00e7\u00e3o de cortadores de grama aut\u00f4nomos personalizados.</p> <p>OpenMower   Desenvolvido por Clemens Elflein, o OpenMower \u00e9 um cortador de grama rob\u00f3tico que utiliza um Raspberry Pi 4, uma placa GPS ArduSimple RTK para navega\u00e7\u00e3o precisa e um microcontrolador Raspberry Pi Pico para tarefas em tempo real. O projeto substitui a eletr\u00f4nica de um cortador de grama comercial por esses componentes, permitindo navega\u00e7\u00e3o sem a necessidade de fios perimetrais. </p> <p>Mowerino Criado pelo engenheiro eletr\u00f4nico 'salmec', o Mowerino \u00e9 um cortador de grama rob\u00f3tico aut\u00f4nomo baseado na plataforma Arduino. Utiliza uma placa Arduino Mega 2560, sensores ultrass\u00f4nicos para detec\u00e7\u00e3o de obst\u00e1culos, inclin\u00f4metro como sensor antitombamento e m\u00f3dulos Bluetooth para controle manual. O chassi e as rodas foram confeccionados com pe\u00e7as impressas em 3D. </p> <p>Capinator Desenvolvido como projeto final da disciplina de Eletr\u00f4nica Embarcada do curso de Engenharia Eletr\u00f4nica da Universidade de Bras\u00edlia, o Capinator \u00e9 um rob\u00f4 cortador de grama aut\u00f4nomo que utiliza o microcontrolador MSP430G2553, sensores ultrass\u00f4nicos HC-SR04 para detec\u00e7\u00e3o de obst\u00e1culos, m\u00f3dulo rel\u00e9 para controle do motor de corte e ponte H L298N para controle dos motores de tra\u00e7\u00e3o. </p> <p>Projeto de Rob\u00f4 Cortador de Grama Aut\u00f4nomo para Uso Residencial Este projeto acad\u00eamico da Universidade Federal do Rio de Janeiro detalha o desenvolvimento de um rob\u00f4 cortador de grama aut\u00f4nomo, incluindo a modelagem de seus principais sistemas e componentes. O estudo aborda sistemas de locomo\u00e7\u00e3o, corte e sensores, utilizando um programa de CAD para modelagem da estrutura. </p> <p>Esses projetos oferecem uma vis\u00e3o dos componentes eletr\u00f4nicos e sensores empregados no desenvolvimento de cortadores de grama aut\u00f4nomos,al\u00e9m das funcionalidades e desafios enfrentados na constru\u00e7\u00e3o desses dispositivos.</p>"},{"location":"comoRodar/","title":"Instru\u00e7\u00f5es de Run","text":"<p>Para executar o projeto, siga os passos abaixo:</p>"},{"location":"comoRodar/#ambiente","title":"Ambiente","text":""},{"location":"comoRodar/#garanta-que-voce-tenha-o-python-38-ou-superior-instalado","title":"Garanta que voc\u00ea tenha o Python 3.8 ou superior instalado","text":"<pre><code>python --version\n</code></pre>"},{"location":"comoRodar/#clone-o-repositorio","title":"Clone o reposit\u00f3rio","text":"<pre><code>git clone https://github.com/PI2-GrassBot/GrassBot.git\n</code></pre>"},{"location":"comoRodar/#crie-um-ambiente-virtual","title":"Crie um ambiente virtual","text":"<pre><code>python -m venv .venv\n</code></pre>"},{"location":"comoRodar/#ative-o-ambiente-virtual","title":"Ative o ambiente virtual","text":"<pre><code># Windows\n.venv\\Scripts\\activate\n\n# Linux\nsource .venv/bin/activate\n</code></pre>"},{"location":"comoRodar/#instale-as-dependencias","title":"Instale as depend\u00eancias","text":"<pre><code>pip install -r requirements.txt\n</code></pre>"},{"location":"comoRodar/#abordagemv1","title":"abordagemV1","text":"<pre><code>cd abordagemV1\n</code></pre>"},{"location":"comoRodar/#simulador","title":"simulador","text":"<pre><code>python src/main.py\n</code></pre> <p>Dentro da interface do pygame, voc\u00ea pode posicionar o GrassBot com o cursor do mouse e clicar no n\u00famero 1 para definir o ponto de partida</p>"},{"location":"comoRodar/#api","title":"api","text":"<pre><code>python src/api/app.py\n</code></pre> <p>Ser\u00e1 aberto um servidor no endere\u00e7o http://localhost:5001/</p>"},{"location":"comoRodar/#interface","title":"interface","text":"<pre><code>python src/ui/interface.py\n</code></pre> <p>Ser\u00e1 aberta uma janela com os controles de power, velocidade e altura da grama do GrassBot no endere\u00e7o http://localhost:5000/</p>"},{"location":"comoRodar/#abordagemv2","title":"abordagemV2","text":"<pre><code>cd abordagemV2\n</code></pre>"},{"location":"comoRodar/#simulador_1","title":"simulador","text":"<pre><code>python src/simulation/main.py\n</code></pre>"},{"location":"comoRodar/#api_1","title":"api","text":"<pre><code>python src/api/api.py\n</code></pre> <p>Ser\u00e1 aberto um servidor no endere\u00e7o http://localhost:5001/</p>"},{"location":"comoRodar/#interface_1","title":"interface","text":"<pre><code>python src/ui/interface.py\n</code></pre> <p>Ser\u00e1 aberta uma janela com os controles de power, velocidade e altura da grama do GrassBot no endere\u00e7o http://localhost:5000/</p>"},{"location":"detalhamento/","title":"Detalhamento do Problema","text":""},{"location":"detalhamento/#contextualizacao","title":"Contextualiza\u00e7\u00e3o","text":"<p>A manuten\u00e7\u00e3o de gramados \u00e9 uma atividade essencial para diversos ambientes, como \u00e1reas residenciais, parques, campos esportivos e jardins p\u00fablicos. No entanto, o processo manual de corte de grama exige esfor\u00e7o f\u00edsico e tempo, al\u00e9m de demandar m\u00e3o de obra recorrente.</p> <p>Al\u00e9m disso, cortadores de grama tradicionais apresentam algumas limita\u00e7\u00f5es, tais como:</p> <ul> <li>Depend\u00eancia de operadores humanos: Necessidade de supervis\u00e3o constante para evitar obst\u00e1culos e garantir um corte uniforme.</li> <li>Risco de acidentes: Uso de l\u00e2minas afiadas pode representar um perigo para operadores e pessoas ao redor.</li> <li>Baixa efici\u00eancia energ\u00e9tica: Modelos convencionais a gasolina geram impactos ambientais e t\u00eam alto consumo de combust\u00edvel.</li> </ul>"},{"location":"detalhamento/#problema-identificado","title":"Problema Identificado","text":"<p>A falta de automa\u00e7\u00e3o no corte de grama cria desafios em efici\u00eancia e seguran\u00e7a, especialmente em \u00e1reas extensas. Assim, prop\u00f5e-se o desenvolvimento de um Cortador de Grama Automatizado, que funcione de maneira aut\u00f4noma, detectando obst\u00e1culos, otimizando rotas e garantindo um corte preciso sem interven\u00e7\u00e3o humana direta.</p>"},{"location":"detalhamento/#objetivos-da-solucao","title":"Objetivos da Solu\u00e7\u00e3o","text":"<ul> <li>Automa\u00e7\u00e3o do processo de corte de grama, reduzindo a necessidade de m\u00e3o de obra.</li> <li>Desenvolvimento de um sistema inteligente para navega\u00e7\u00e3o aut\u00f4noma, capaz de mapear o terreno, detectar obst\u00e1culos e otimizar rotas.</li> <li>Cria\u00e7\u00e3o de um prot\u00f3tipo funcional de software, incluindo um emulador para simular o comportamento do cortador.</li> <li>Efici\u00eancia energ\u00e9tica e seguran\u00e7a, garantindo que o equipamento opere de maneira sustent\u00e1vel e sem riscos.</li> </ul>"},{"location":"requisitos/","title":"Requisitos","text":""},{"location":"requisitos/#introducao","title":"Introdu\u00e7\u00e3o","text":"<p>Este documento tem como objetivo apresentar os requisitos funcionais e n\u00e3o funcionais do projeto GrassBot. O sistema deve ser capaz de identificar a \u00e1rea de corte, percorrer a \u00e1rea delimitada seguindo um algoritmo de cobertura eficiente, detectar obst\u00e1culos em tempo real e recalcular a rota para evit\u00e1-los. O software deve permitir ajuste da altura de corte e velocidade de deslocamento, possuir uma interface para ligar e desligar, iniciar apenas se a bateria estiver acima de 80% e permitir a inser\u00e7\u00e3o de obst\u00e1culos em tempo real. Estes requisitos foram elicitados com base nas necessidades identificadas no benchmarking, no detalhamento do problema e brainstorming da equipe.</p>"},{"location":"requisitos/#requisitos-funcionais","title":"Requisitos Funcionais","text":"C\u00f3digo Descri\u00e7\u00e3o RF01 O sistema deve identificar a \u00e1rea de corte de forma aut\u00f4noma. RF02 O cortador deve ser capaz de percorrer a \u00e1rea delimitada seguindo um algoritmo de cobertura eficiente. RF03 O software deve detectar obst\u00e1culos em tempo real e recalcular a rota para evit\u00e1-los. RF04 O emulador deve simular as fun\u00e7\u00f5es do cortador, permitindo a valida\u00e7\u00e3o do algoritmo antes da implementa\u00e7\u00e3o f\u00edsica. RF05 O software deve permitir ajuste da altura de corte e velocidade de deslocamento. RF06 O software deve possuir uma interface para ligar e desligar. RF07 O sistema s\u00f3 deve iniciar caso a bateria esteja acima de 80%. RF08 O usu\u00e1rio dever\u00e1 conseguir inserir obst\u00e1culos em tempo real."},{"location":"requisitos/#requisitos-nao-funcionais","title":"Requisitos N\u00e3o Funcionais","text":"C\u00f3digo Descri\u00e7\u00e3o RNF01 O sistema deve ser desenvolvido utilizando Python e frameworks de simula\u00e7\u00e3o para a cria\u00e7\u00e3o do emulador. RNF02 A interface do software deve ser intuitiva e acess\u00edvel para usu\u00e1rios sem conhecimento t\u00e9cnico avan\u00e7ado. RNF03 O processamento dos dados de sensores deve ocorrer em tempo real para permitir ajustes r\u00e1pidos no percurso. RNF04 O consumo energ\u00e9tico do sistema embarcado deve ser otimizado para garantir maior autonomia da bateria. RNF05 O tempo de resposta para recalculo de rota ao detectar um obst\u00e1culo deve ser inferior a 2 segundos. RNF06 A emula\u00e7\u00e3o dever\u00e1 conter mocks de sensores ultras\u00f4nicos."},{"location":"sensoriamento/","title":"Sensoriamento","text":""},{"location":"sensoriamento/#introducao","title":"Introdu\u00e7\u00e3o","text":"<p>O sensoriamento \u00e9 uma etapa fundamental para o funcionamento de qualquer rob\u00f4 aut\u00f4nomo, incluindo o GrassBot. Sensores s\u00e3o dispositivos que captam informa\u00e7\u00f5es do ambiente e as convertem em sinais el\u00e9tricos ou digitais que podem ser processados pelo sistema de controle do rob\u00f4. Eles fornecem dados essenciais para a navega\u00e7\u00e3o, detec\u00e7\u00e3o de obst\u00e1culos, localiza\u00e7\u00e3o e intera\u00e7\u00e3o com o ambiente.</p> <p>Neste documento, apresentamos uma vis\u00e3o geral dos sensores que ser\u00e3o emulados no simulador do GrassBot. Esses sensores s\u00e3o essenciais para a opera\u00e7\u00e3o aut\u00f4noma do rob\u00f4 cortador de grama, permitindo que ele navegue de forma segura e eficiente pelo gramado.</p> <p>Para a defini\u00e7ao de sensoriamento, foram utilizadas as referencias obtidas durante o benchmarking, que apresentam os sensores mais comuns em rob\u00f4s cortadores de grama aut\u00f4nomos e o como eles s\u00e3o posicionados no rob\u00f4.</p>"},{"location":"sensoriamento/#sensores-utilizados","title":"Sensores Utilizados","text":""},{"location":"sensoriamento/#1-sensores-ultrassonicos","title":"1. Sensores Ultrass\u00f4nicos","text":"<p>Os sensores ultrass\u00f4nicos s\u00e3o amplamente utilizados em rob\u00f3tica para detec\u00e7\u00e3o de obst\u00e1culos. Eles emitem ondas sonoras de alta frequ\u00eancia e medem o tempo que leva para o som refletido retornar ao sensor. Com base nesse tempo, \u00e9 poss\u00edvel calcular a dist\u00e2ncia at\u00e9 o objeto mais pr\u00f3ximo.</p> <p>O modelo sugerido para utilizar \u00e9 o sensor HC-SR04, que \u00e9 preciso, de baixo custo e f\u00e1cil de integrar com microcontroladores.</p> <p></p>"},{"location":"sensoriamento/#2-sensores-de-cor","title":"2. Sensores de Cor","text":"<p>Os sensores de cor s\u00e3o empregados para identificar diferentes tonalidades e padr\u00f5es de cores no ambiente. Eles s\u00e3o \u00fateis para detectar linhas de demarca\u00e7\u00e3o, \u00e1reas de corte e outros elementos visuais que auxiliam na navega\u00e7\u00e3o do rob\u00f4.</p> <p>O modelo sugerido para utilizar \u00e9 o sensor TCS230, que \u00e9 capaz de detectar uma ampla gama de cores e fornecer informa\u00e7\u00f5es precisas sobre a tonalidade de cada pixel. </p>"},{"location":"sensoriamento/#posicionamento-dos-sensores","title":"Posicionamento dos Sensores","text":"<p>Os sensores ser\u00e3o posicionados estrategicamente no GrassBot para garantir uma cobertura eficiente do ambiente. Durante a simulac\u00e3o, os sensores ser\u00e3o emulados da seguinte maneira: - Sensores Ultrass\u00f4nicos: Ser\u00e3o simulados em quatro dire\u00e7\u00f5es (frente, tr\u00e1s, esquerda e direita) a partir do centro do cortador de grama. Eles detectar\u00e3o obst\u00e1culos em um raio de 30 pixels.</p> <ul> <li>Sensores de Cor: Ser\u00e3o simulados na parte inferior do cortador de grama, apontados para o solo a frente do rob\u00f4. Eles identificar\u00e3o a cor da grama e outras \u00e1reas de interesse.</li> </ul>"}]}